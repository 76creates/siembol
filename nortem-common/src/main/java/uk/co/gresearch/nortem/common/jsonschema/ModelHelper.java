package uk.co.gresearch.nortem.common.jsonschema;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.github.reinert.jjschema.Attributes;
import com.github.reinert.jjschema.SchemaIgnore;
import org.apache.commons.lang3.ClassUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.annotation.Annotation;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;

/**
 * Helper class that allows to modify json scheme generated by com.github.reinert.jjschema in order to
 * - use default values from Dto classes
 * - preserve ordering of fields from Dto classes
 *
 */

public class ModelHelper {
    private enum AnnotationType {
        TITLE,
        IGNORE,
        FIELD_NAME
    }

    private static final Logger LOG = LoggerFactory
            .getLogger(MethodHandles.lookup().lookupClass());
    private static final ObjectReader JSON_READER = new ObjectMapper()
            .readerFor(new TypeReference<Map<String, Object>>() {});
    private static final String NO_TITLE_ERROR_MSG = "Can not find title annotation in Dto Class";
    private static final String NO_FIELDS_ERROR_MSG = "Dto class without fields";
    private static ObjectMapper JSON_MAPPER = new ObjectMapper();
    private static final String PROPERTIES_KEY = "properties";
    private static final String TITLE_KEY = "title";
    private static final String DEFAULT_KEY = "default";
    private static final String TYPE_KEY = "type";
    private static final String ITEMS_KEY = "items";
    private static final String ARRAY_TYPE = "array";
    private static final String OBJECT_TYPE = "object";

    private final Map<String, Map<String, Object>> defaultValues;
    private final Map<String, List<String>> fieldNames;

    private ModelHelper(Map<String, Map<String, Object>> defaultValues,
                       Map<String, List<String>> fieldNames) {
        this.defaultValues = defaultValues;
        this.fieldNames = fieldNames;
    }

    private static Map<AnnotationType, String> getAnnotationMap(Annotation[] annotations) {
        Map<AnnotationType, String> ret = new HashMap<>();

        for (Annotation annotation : annotations) {
            if (annotation.annotationType().equals(Attributes.class)) {
                Attributes attr = (Attributes) annotation;
                ret.put(AnnotationType.TITLE, ((Attributes)annotation).title());
            }
            if (annotation.annotationType().equals(SchemaIgnore.class)) {
                ret.put(AnnotationType.IGNORE, "");
            }
            if (annotation.annotationType().equals(JsonProperty.class)) {
                ret.put(AnnotationType.FIELD_NAME,((JsonProperty) annotation).value());
            }
        }
        return ret;
    }

    private static boolean isInterestingType(Class type) {
        return !ClassUtils.isPrimitiveOrWrapper(type)
                && !type.equals(String.class)
                && !type.isEnum();
    }

    public static ModelHelper createModelHelper(Class<?> clazz) throws Exception {
        Map<String, Map<String, Object>> defaultValues = new HashMap<>();
        Map<String, List<String>> fieldNames = new HashMap<>();

        Stack<Class<?>> stack = new Stack<>();
        stack.push(clazz);
        while (!stack.empty()) {
            Class<?> current = stack.pop();

            Map<AnnotationType, String> classAnnotations = getAnnotationMap(current.getDeclaredAnnotations());
            String title = classAnnotations.get(AnnotationType.TITLE);

            if (title == null) {
                LOG.error(NO_TITLE_ERROR_MSG);
                throw new IllegalStateException(NO_TITLE_ERROR_MSG);
            }

            if (fieldNames.containsKey(title)) {
                continue;
            }

            List<String> orderedNames = new ArrayList<>();
            Field[] fields = current.getDeclaredFields();
            for (Field field : fields) {
                Map<AnnotationType, String> fieldAnnotations = getAnnotationMap(field.getDeclaredAnnotations());
                if (fieldAnnotations.containsKey(AnnotationType.IGNORE)) {
                    continue;
                }

                String fieldName = fieldAnnotations.containsKey(AnnotationType.FIELD_NAME)
                        ? fieldAnnotations.get(AnnotationType.FIELD_NAME)
                        : field.getName();

                orderedNames.add(fieldName);

                Type genericFieldType = field.getGenericType();
                if (genericFieldType instanceof ParameterizedType) {
                    //we handle generic parameters  e.g. List<DtoClass>
                    for (Type fieldArgType : ((ParameterizedType)genericFieldType).getActualTypeArguments()) {
                        if (isInterestingType((Class)fieldArgType)) {
                            stack.push((Class)fieldArgType);
                        }
                    }
                } else if (isInterestingType(field.getType())) {
                    stack.push(field.getType());
                }
            }

            if (orderedNames.isEmpty()) {
                LOG.error(NO_FIELDS_ERROR_MSG);
                throw new IllegalStateException(NO_FIELDS_ERROR_MSG);
            }
            fieldNames.put(title, orderedNames);
            if (current.isEnum()) {
                continue;
            }

            Object defaultInstance = current.getDeclaredConstructor().newInstance();
            ObjectWriter writerNonNull = new ObjectMapper()
                    .setSerializationInclusion(JsonInclude.Include.NON_EMPTY)
                    .writerFor(current);

            String nonNullJson = writerNonNull.writeValueAsString(defaultInstance);
            Map<String, Object> nonNullObject = JSON_READER.readValue(nonNullJson);
            nonNullObject.keySet().removeIf(x -> !orderedNames.contains(x));

            if (!nonNullObject.isEmpty()) {
                defaultValues.put(title, nonNullObject);
            }
        }

        return new ModelHelper(defaultValues, fieldNames);
    }

    private void addDefaultValue(ObjectNode objectNode, Map<String, Object> defaults) {
        ObjectNode properties = (ObjectNode)objectNode.get(PROPERTIES_KEY);
        for (String propertyName : defaults.keySet()) {
            ObjectNode property = (ObjectNode)properties.get(propertyName);

            JsonNode defaultValue = JSON_MAPPER.convertValue(defaults.get(propertyName), JsonNode.class);
            property.set(DEFAULT_KEY, defaultValue);
        }
    }

    private void reorderFields(ObjectNode objectNode, List<String> fields) {
        ObjectNode properties = (ObjectNode)objectNode.get(PROPERTIES_KEY);
        for (String field : fields) {
            JsonNode current = properties.get(field);

            if (current != null) {
                properties.remove(field);
                properties.set(field, current);
            }
        }
    }

    public ObjectNode getEnrichedSchema(JsonNode schema) {
        ObjectNode root = schema.deepCopy();
        Stack<ObjectNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.empty()) {
            ObjectNode current = stack.pop();
            String type = current.get(TYPE_KEY).asText();

            if (ARRAY_TYPE.equals(type)) {
                ObjectNode items = (ObjectNode)current.get(ITEMS_KEY);
                stack.push(items);
            } else if (OBJECT_TYPE.equals(type)) {
                ObjectNode properties = (ObjectNode)current.get(PROPERTIES_KEY);
                String title = current.get(TITLE_KEY).asText();

                if (defaultValues.containsKey(title)) {
                    addDefaultValue(current, defaultValues.get(title));
                }

                if (fieldNames.containsKey(title)) {
                    reorderFields(current, fieldNames.get(title));
                }

                for (Iterator<Map.Entry<String, JsonNode>> it = properties.fields(); it.hasNext(); ) {
                    Map.Entry<String, JsonNode> property = it.next();
                    stack.push((ObjectNode)property.getValue());
                }
            }
        }
        return root;
    }
}
