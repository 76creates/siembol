{
    "response": {
        "deployment": {
            "version": "rules_version",
            "config_array": "rules"
        },
        "perConfigSchemaPath": "attributes.rules_schema.properties.rules.items",
        "unionType": {
            "unionPath": "/evaluators",
            "unionSelectorName": "evaluator_type"
        },
        "name": "rule_name",
        "version": "rule_version",
        "author": "rule_author",
        "description": "rule_description",
        "labelsFunc": "const ret = []; if (model.evaluators && model.evaluators.length > 0){for(const e of model.evaluators) {ret.push(Object.keys(e)); console.log(model)} } return ret;",
        "testing": {
            "helpMessage": "Copy a suitable siembol alert to test the rule against.",
            "perConfigTestEnabled": true,
            "deploymentTestEnabled": true,
            "testCaseEnabled": true,
            "eventName": "event",
            "eventHelper": "<json log>"
        }
    },
    "alert": {
        "deployment": {
            "version": "rules_version",
            "config_array": "rules",
            "extras": [
                "tags"
            ]
        },
        "perConfigSchemaPath": "attributes.rules_schema.properties.rules.items",
        "name": "rule_name",
        "version": "rule_version",
        "author": "rule_author",
        "description": "rule_description",
        "labelsFunc": "const ret = ['SourceType:' + model.source_type]; if (model.tags !== undefined) { ret.push(...model.tags.map(t => t.tag_name + ':' + t.tag_value));} return ret;",
        "testing": {
            "helpMessage": "Copy a json event to test the rule against.",
            "perConfigTestEnabled": true,
            "deploymentTestEnabled": true,
            "testCaseEnabled": true,
            "eventName": "event",
            "eventHelper": "<json log>"
        }
    },
    "correlationalert": {
        "deployment": {
            "version": "rules_version",
            "config_array": "rules",
            "extras": [
                "tags"
            ]
        },
        "perConfigSchemaPath": "attributes.rules_schema.properties.rules.items",
        "name": "rule_name",
        "version": "rule_version",
        "author": "rule_author",
        "description": "rule_description",
        "labelsFunc": "const ret = []; if(model.correlation_attributes.length > 0) { for(const alert of model.correlation_attributes[0].alerts){ret.push(alert.alert);}} if(model.tags !== undefined) { ret.push(...model.tags.map(t => t.tag_name + ':' + t.tag_value));} return ret;",
        "testing": {
            "helpMessage": "Testing is not currently supported",
            "perConfigTestEnabled": false,
            "deploymentTestEnabled": false,
            "testCaseEnabled": false,
            "eventName": "event",
            "eventHelper": "<json log>"
        }
    },
    "parserconfig": {
        "deployment": {
            "version": "parsers_version",
            "config_array": "parsers_configurations"
        },
        "perConfigSchemaPath": "attributes.rules_schema.properties.parsers_configurations.items",
        "name": "parser_name",
        "version": "parser_version",
        "author": "parser_author",
        "description": "parser_description",
        "labelsFunc": "const ret = []; if (model.parser_attributes) {ret.push(model.parser_attributes.parser_type);} if (model.parser_extractors && model.parser_extractors.length > 0){for(const p of model.parser_extractors) {ret.push(p.extractor_type)} } return ret;",
        "testing": {
            "helpMessage": "Copy a raw text log here to test the parser",
            "perConfigTestEnabled": true,
            "deploymentTestEnabled": true,
            "testCaseEnabled": true,
            "eventName": "event",
            "eventHelper": "<raw text log>"
        }
    },
    "parsingapp": {
        "deployment": {
            "version": "parsing_applications_version",
            "config_array": "parsing_applications"
        },
        "perConfigSchemaPath": "attributes.rules_schema.properties.parsing_applications.items",
        "name": "parsing_app_name",
        "version": "parsing_app_version",
        "author": "parsing_app_author",
        "description": "parsing_app_description",
        "labelsFunc": "const ret = []; if (model.parsing_app_settings) {ret.push(model.parsing_app_settings.parsing_app_type); for(const topic of model.parsing_app_settings.input_topics){ ret.push(topic);}} return ret;",
        "testing": {
            "helpMessage": "Copy a raw text log here to test the parser",
            "perConfigTestEnabled": false,
            "deploymentTestEnabled": false,
            "testCaseEnabled": false,
            "eventName": "event",
            "eventHelper": "<raw text log>"
        }
    },
    "enrichment": {
        "deployment": {
            "version": "rules_version",
            "config_array": "rules"
        },
        "perConfigSchemaPath": "attributes.rules_schema.properties.rules.items",
        "name": "rule_name",
        "version": "rule_version",
        "author": "rule_author",
        "description": "rule_description",
        "labelsFunc": "const ret = []; if(model.source_type) {ret.push(model.source_type);} if(model.table_mapping) {if(model.table_mapping.table_name){ret.push(model.table_mapping.table_name);} if(model.table_mapping.joining_key){ret.push(model.table_mapping.joining_key);}} return ret;",
        "testing": {
            "helpMessage": "Use the example event structure to test the enrichment rule",
            "perConfigTestEnabled": true,
            "deploymentTestEnabled": false,
            "testCaseEnabled": true,
            "eventName": "test_specification",
            "eventHelper": "{\n\t\"event\": {\n\t\t\"is_alert\": false,\n\t\t\"source.type\": \"*\",\n\t\t\"<Joining_Key>\": \"123.123.123.123\"\n\t},\n\t\"testing_table_name\": \"test_table_name\",\n\t\"testing_table_mapping\": {\n\t\t\"123.123.123.123\": {\n\t\t\t\"<Table_Field_Name>\": \"some-hostname\"\n\t\t}\n\t\n\t}\n}"
        }
    }
}